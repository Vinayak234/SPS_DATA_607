---
title: 'DATA 607:  Project 1'
author: "VINAYAK PATEL"
date: "September 23, 2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(stringr)
library(DT)
library(ggplot2)
```

## Abstract

In this project, goal is to create dataset from given a text file with chess tournament results where the information has some structure. I will create an R Markdown file that generates a .CSV file (that could for example be imported into a SQL database) with the following information for all of the players:

Player's Name, Player's State, Total Number of Points, Player's Pre-Rating, and Average Pre Chess Rating of Opponents

### Data Import
```{r, warning=FALSE, comment=NA}

line <- readLines('tournamentinfo.txt')
head(line,10)

```

## Data Grouping
However, the data is already essentially laid out in a readable table format, it is not useable for analysis. Beacause it contains different syntex. Table has pattern which repeates everytime.  

### Column Split
Let's find out how much space each column take to hold the information. 


```{r}
pair_start_point <- 1
pair_end_point <- unname(str_locate_all(pattern = '\\|', line[5])[[1]][1,1]) -1

player_start_point <-pair_end_point+2
player_end_point <- unname(str_locate_all(pattern = '\\|', line[5])[[1]][2,1]) -1

total_start_point <- player_end_point+2
total_end_point <- unname(str_locate_all(pattern = '\\|', line[5])[[1]][3,1])-1

opp_start_point<-total_end_point+2
end_point<-unname(str_locate_all(pattern = '\\|', line[5])[[1]][10,1])

```


### raw Split
Each player respresents 2 line of record which reapeat after 3 lines. I will use sequence which will help to fetch record from text file and will skip 3 line and fatch it again. 

```{r}

playername_line = 5
uscf_id_line = 6
total_line = 196
repeat_pattern=3

group1 <- line[seq(playername_line, total_line, repeat_pattern)]
group2 <- line[seq(uscf_id_line, total_line, repeat_pattern)]

```
we need 5 differnt columns 
1. player name
2. player state
3. total point
4. Pre rating
5. avg.rating

### *Player Name* 
```{r}

fetch_name  <- substr(group1, player_start_point, player_end_point)
PlayerName <- str_to_title(str_trim(fetch_name))
PlayerName

```

### *Player State*
```{r}
fetch_state <- substr(group2, pair_start_point, pair_end_point)
State <- str_trim(fetch_state)
State

# start our df
chess <- data.frame(PlayerName, State)
chess
```

### *Total Points*
```{r}
point <- as.numeric(substr(group1, total_start_point, total_end_point))
chess$TotalPoints <- point
point

```

### *Pre-Rating*

```{r}
pRating <- substr(group2, player_start_point, player_end_point)
pRating <- str_extract(pRating, ': * [[:digit:]]{2,}') %>% parse_number()
chess$PreRating <- pRating
pRating

```

### *Avg Opponent's Pre-Rating*

```{r}
fetch_opp <- substr(group1, opp_start_point, end_point)
fetch_opp <- as.matrix(str_extract_all(fetch_opp, '\\b\\d{1,}'))

calculate_rating <- function(x, y) {
    temp <- x[y]
   
    for (i in temp){
        rate <- 0
        k <- 0
        for(j in i) {
            k <- k + 1
            rate <- rate + chess$PreRating[as.numeric(j)]
        }
        rate <- round(rate / k)
       
    }
    return(rate)
}

chess$AvgOppPreRating <- apply(fetch_opp, 1, calculate_rating)

```

### *Export*
```{r}
datatable(chess)

# export
write.csv(chess, "chess.csv", row.names=FALSE)
```

### *Conclusion*

The data was already essentially laid out in a readable table format, we were able to use see a pattern and split the data.